---
title: 调整优化
description: 如何调整 Velocity 以实现更好的性能
slug: velocity/tuning
---

Velocity 默认就具备出色的性能。
我们从智能的算法选择、战略性地使用原生库，一直到 JVM 层面进行优化，
让 JVM 在优化代码时能够做出更好的决策。

## 在 Linux 上托管代理

Velocity 配备了高性能的、经过特别优化的原生库，用于压缩和加密，并且集成了 Netty 的原生传输。
然而，由于支持限制，编译后的原生库仅验证可在 Linux x86_64 和 aarch64 上运行。
虽然 Velocity 不需要原生库来运行，但如果没有原生库，性能会有所下降。
因此，我们强烈建议所有生产环境的 Velocity 部署运行在 x86_64 Linux 上。

## 合理分配服务器资源

你应该始终确保为代理分配了正确的堆内存、网络带宽，并为特定时间内的玩家数量选择合适的 CPU。
例如，你不太可能在 Raspberry Pi Zero 上容纳 1,000 名玩家，
但如果你使用的是英特尔或 AMD 的最新高端服务器 CPU，成功的可能性会大大增加。

没有“一刀切”的硬件建议，
只有关于你可以提升容纳的玩家数量的一般指导方针：

- 优先选择核心数量多但时钟频率较低的 CPU。
  与 Minecraft 服务器不同，Velocity 实际上可以从额外的核心中受益，单线程性能并不那么重要。
- 你应该始终有足够的内存来运行 Velocity，包括 JVM 开销和操作系统的空间。
  对于大致的最低推荐内存数量，将代理堆的大小加倍，然后再加上 2GB。
  例如，对于一个堆大小为 2GB 的代理，计划至少需要 6GB 的内存。
- 磁盘速度并不重要。固态硬盘固然不错，但并非严格必需。
  同样，磁盘容量也不重要。

### 关于推测执行安全漏洞的特别说明

从 2018 年开始，
人们发现了许多与现代 CPU 使用的 [推测执行](https://en.wikipedia.org/wiki/Speculative_execution) 相关的安全漏洞。

这些漏洞的缓解措施可能会带来痛苦的性能影响，尤其是在容易受到 Meltdown 影响的处理器上，
如果在虚拟机中运行，这种影响会进一步加剧。
Velocity 作为一种网络应用程序，对缓解措施引入的性能损失特别敏感。

为了将这些性能损失降到最低，
我们建议在配备有针对 Spectre 和 Meltdown 的缓解措施的 CPU 的机器上托管你的代理。
通常，2019 年及以后发布的处理器都包含针对 Spectre 和 Meltdown 的保护措施。

如果你使用的是容易受到 Spectre 和/或 Meltdown 影响的 CPU，并且愿意为了性能而冒险，那么根据你使用的操作系统，也可以禁用 Spectre/Meltdown 的缓解措施。 相关中文文章：
[关闭 Spectre 和 Meltdown 漏洞补丁来提升系统性能](https://konata.tech/2021/11/13/disableMitigations/#!)，[禁用 Meltdown、Spectre 和 Retbleed 补丁，使 CPU 恢复全盛状态](https://ngabbs.com/read.php?tid=40601311)

但请注意，你是在 _自行承担风险_ 的情况下禁用这些安全缓解措施的。
Velocity 项目并不推荐你禁用这些缓解措施。

## 分配足够的堆内存

除了有足够的 CPU、内存和网络带宽外，你还必须为代理分配足够的 Java 堆内存。
不这样做可能会导致延迟，在严重的情况下，
代理可能会因为内存不足而被 Java 虚拟机终止。

一般的经验法则是每 500 名玩家分配 512MB 的堆内存，
并额外增加一些空间以应对误差（通常增加 1GB）。
例如，如果你希望在单个代理上容纳 1,000 名玩家，计划分配 2GB 的堆内存。

### 容器的特别说明

**如果你使用的是容器化设置（例如使用 Kubernetes、Pterodactyl 或直接使用 Docker），你不应该将全部内存分配给堆！**
这样做很可能会导致代理被内核的内存不足杀手进程杀死，
从而导致你的代理崩溃，而且很可能是最糟糕的时刻。

为堆分配一半的代理容器总内存是一个安全（尽管比较保守）的设置。
例如，如果你的代理端需要容纳 1,000 名玩家，
那么为容器分配 4GB 的内存，并给代理端分配 2GB 的堆内存。

## 调整启动参数

我们还建议调整你的启动参数。当前的建议是：

```
-XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -XX:MaxInlineLevel=15
```

你应该在 `java` 命令之后但在 `-jar` 参数之前添加这些参数。

### 参数说明

这些参数大多专注于调整 G1 垃圾回收器以更好地适应 Velocity 的工作负载。
其中一个参数（`-XX:MaxInlineLevel=15`）通常可以提高性能。

在 Java 9 发布之前，
默认的 Java 垃圾回收器是 Parallel GC。
这是一个会暂停所有线程的垃圾回收器，它会并行地完成其工作。
问题是它的暂停时间往往很长，不适合 Minecraft（通常表现为无法解释的延迟峰值）。

我们推荐为 Velocity 使用 G1 分区垃圾回收器，
原因有以下几点：

- 它在吞吐量和暂停时间之间取得了恰当的平衡。
  吞吐量大致可以指代理端可以完成的工作量。
- 它与大多数设置兼容（它在 Java 8 中可用，
  这是我们支持的最早版本的 Java）。

使用这些参数的设置往往具有非常低的（每几分钟少于 10 毫秒）垃圾回收暂停时间，
这对于 Minecraft 来说是非常好的。

### 其他配置

:::caution[注意]

偏离我们推荐的配置需要你自己承担风险。

:::

Velocity 是一个非常接近遵循代际假设的应用程序。
它还经过了优化，以尽可能减少对垃圾回收器的负担。

#### ZGC

ZGC（Z Garbage Collector）在 Java 11 中引入，并在 Java 15 中稳定下来，
已经被证明在 Velocity 的大规模部署中非常成功。

在核心上，ZGC 是一个并发的、无代的垃圾回收器，它强调低延迟，以牺牲吞吐量为代价。
鉴于 Velocity 作为一个网络代理的性质，低吞吐量和高吞吐量都很重要，
我们建议谨慎使用 ZGC，并且只有在你使用 Java 15 或更高版本时才使用它。

ZGC 的主要调整参数是堆大小——如果 ZGC 不能比代理分配内存更快地收集垃圾，
那么生成垃圾的线程将被临时暂停，导致代理端看起来很卡顿。
我们的堆大小建议仍然适用，但如有必要，准备好给代理端分配更多内存。

#### Shenandoah

Shenandoah 在 Java 11 中引入，并在 Java 15 中被宣布为稳定。
它与 G1 类似，是一个并发的、分代的垃圾回收器，但它会并行完成更多工作。

Velocity 团队尚未听说有任何在生产环境中成功部署 Shenandoah 与 Velocity 的案例。

#### OpenJ9

OpenJ9 是 HotSpot JVM 的一个替代品，它源自 IBM 的 J9 JVM，主要专注于云工作负载。
因此，它的行为与 HotSpot 非常不同。
相应地，它有一套完全不同的垃圾回收器。

默认的 `gencon` 垃圾回收器应该可以很好地与 Velocity 一起工作。
