---
title: 区域逻辑
description: 对 Folia 区域化器工作原理的概述
slug: folia/reference/region-logic
---

## 基础区域化逻辑

## 区域

区域仅仅是一组拥有区块位置和与该区域绑定的实现定义的唯一数据对象。
重要的是要注意，对于任何非死亡区域 x，对于它拥有的每个区块位置 y，不存在其他非死亡区域 z，使得区域 z 拥有区块位置 y。

## 区域化器

每个世界都有自己的区域化器。
区域化器是用来描述 `ThreadedRegionizer` 类执行的创建、维护和销毁区域的逻辑的术语。
区域的维护是通过将附近的区域合并在一起、标记哪些区域有资格被计时，以及最后将任何区域拆分成更小的独立区域来完成的。
实际上，这是确保附近一组区块被视为一个独立区域的逻辑。

## 区域化器提供的保证

区域化器提供了一组重要的不变量，允许区域在没有竞态条件的情况下并行计时：

### 第一个不变量

第一个不变量很简单，即任何存在的区块持有者都只有一个对应的区域。

### 第二个不变量

第二个不变量是，对于每一个 _存在的_ 区块持有者 x，如果它包含在一个区域内，那么在其“合并半径”内的每个区块位置都由该区域拥有。
实际上，这个不变量保证了该区域附近没有其他区域，从而允许该区域在计时时假设它可以为“靠近”它的区块持有者创建数据。

### 第三个不变量

第三个不变量是，一个正在计时的区域 _不能_ 在其计时时扩展它所拥有的区块位置。
第三个不变量很重要，因为它防止了正在计时的区域在计时时“争夺”附近未拥有的区块，以确保它们真正地并行计时，无论它们在计时时可能发出什么区块加载请求。

为了符合第一个不变量，区域化器将在正在计时的区域 _周围_ 创建“临时”区域。
具体来说，在这种情况下，“周围”意味着足够接近以至于需要合并，但又不至于远到被认为是独立的。
在这种情况下创建的临时区域将在正在计时的区域完成计时时合并到该区域中。

第二个不变量和第三个不变量结合起来，使得区域化器能够保证一个正在计时的区域可以创建并访问其周围的区块持有者（即同步加载），而不会出现与另一个区域冲突的可能性。

### 第四个不变量

第四个不变量是，一个区域只能处于四种状态之一：“临时”、“就绪”、“计时”或“死亡”。

“就绪”状态允许区域转换到“计时”状态，而“临时”状态用于那些可能不会计时的区域。
“死亡”状态用于标记那些不应被使用的区域。

状态转换将在后面解释，因为它与区域化器的合并和拆分逻辑有关。

## 区域化器实现

区域化器的实现是对类 `ThreadedRegionizer` 如何遵守前面描述的四个不变量的描述。

### 将世界划分为多个部分

区域化器并不是基于区块坐标进行操作，而是基于“区域部分坐标”进行操作。
区域部分坐标仅仅表示在一个网格上对 NxN 区块的分组，其中 N 是 2 的某个幂。
实际的数字是模糊的，因为区域部分坐标仅仅是区块分组的一个内部细节。
例如，当 N=16 时，区域部分 (0,0) 涵盖了所有 x 在 [0,15] 和 z 在 [0,15] 的区块。
这个概念类似于区块坐标 (0,0) 涵盖了所有 x 在 [0,15] 和 z 在 [0,15] 的方块。
另一个例子是当 N=16 时，区块 (17,-5) 包含在区域部分 (1,-1) 内。

区域部分坐标仅作为区域化器中的性能权衡使用，因为通过将区块近似到其区域坐标，它可以将 NxN 区块视为一个单元来进行区域化处理。
这意味着区域并不拥有区块位置，而是拥有区域部分位置。
NxN区块的分组使得区域化逻辑仅在区域部分的创建/销毁时执行。
例如，当 N=16 时，这意味着在添加区块/区域重新计算等区域中，假设区域部分始终是满的，最多可以减少 NxN-1=255 次操作。

### 实现变量

实现变量控制区域化器维护和合并区域的积极程度。

#### 重新计算次数

重新计算次数是一个区域必须拥有的最少区域部分数量，才允许它进行重新计算。
请注意，重新计算操作只是计算一个区域内存在的独立区域集合，以检查是否可以执行拆分操作。
这是一个简单的性能调节参数，允许关闭小区域的拆分逻辑，因为小区域本身不太可能被拆分。

#### 最大死亡部分百分比

最大死亡部分百分比是一个区域中必须存在的最少死亡部分的百分比，才允许该区域运行重新计算逻辑。

#### 空部分创建半径

空部分创建半径变量用于确定在至少有一个区块的任何区域部分周围应存在多少个空的区域部分。

内部，区域化器通过防止正在运行的区域拥有新的区域部分来强制执行第三个不变量。
在任何非空部分周围创建空部分将强制执行第二个不变量。

#### 区域部分合并半径

合并半径变量用于确保对于任何现有的区域部分 x，对于合并半径内的任何其他区域部分 y，要么被拥有 x 的区域拥有，要么正在等待合并到拥有 x 的区域中，或者拥有 x 的区域正在等待合并到拥有 y 的区域中。

#### 区域部分区块偏移

区域部分区块偏移就是 log₂（网格大小N）。
因此，N = 1 << 区域部分区块偏移。
从区块位置到区域部分的转换还定义为：区域坐标 = 区块坐标 >> 区域部分区块偏移。

### 操作

区域化器通过调用`ThreadedRegionizer#addChunk(x, z)`或`ThreadedRegionizer#removeChunk(x, z)`来操作，当区块持有者被创建或销毁时。

此外，调用者可以通过`ThreadedRegion#tryMarkTicking`尝试将一个区域从“准备”状态移动到“运行”状态。
需要注意的是，如果区域不在“准备”状态，这个函数将返回`false`，因为即使是过去被认为是“准备”状态的区域（即计划运行的区域），也可能会意外地被标记为“过渡”状态。
因此，调用者需要处理这些情况。
成功将区域标记为运行的调用者必须通过`ThreadedRegion#markNotTicking`将其标记为非运行状态。

函数`ThreadedRegion#markNotTicking`如果区域从“运行”状态迁移到“准备”状态，则返回`true`，在所有其他情况下返回`false`。
实际上，它返回当前区域是否可能在稍后再次被运行。

### 区域部分状态

区域部分状态是“死亡”或“存活”之一。
如果一个区域部分至少包含一个区块位置，则它还可以被认为是“非空”的，否则为“空”。

一个区域部分被认为是“死亡”的，当且仅当该区域部分是“空”的，并且在其空部分创建半径内不存在其他“空”的部分。

死亡部分状态的存在纯粹是为了性能，因为它允许延迟区域的重新计算逻辑，直到该区域包含足够多的死亡部分。
然而，死亡部分仍然被认为属于拥有它们的区域，就像存活部分一样。

### 添加区块（`addChunk`）

向区域化器添加区块可以归结为两种情况：

#### 目标区域部分已经存在且不为空

在这种情况下，它只是将区块添加到该部分并返回。

#### 目标区域部分不存在或为空

在这种情况下，如果该区域部分不存在，则会创建该区域部分。
此外，还会创建“创建空部分半径”内的区域部分。

然后，将“创建空部分半径”+“合并半径”内的任何区域收集到一个集合 X 中。
这个集合代表了需要合并的区域，以遵守第二个不变量。

如果集合 X 中没有元素，则会创建一个处于“准备”状态的区域来拥有所有创建的部分。

如果集合 X 中只有一个区域，则不需要合并任何区域，也不会修改任何区域状态，这些部分将被添加到这一个区域中。

当集合 X 中有超过一个区域时，需要执行合并逻辑。
从集合 X 中选择一个不处于运行状态的区域x。
如果不存在这样的 x，则创建一个区域 x。
每个创建的区域部分都被添加到集合 x 中，因为它是已知的不处于运行状态的部分——这是为了遵守第三个不变量。

集合 X 中每个不是 x 的区域 y，如果 y 不处于运行状态，则将其合并到 x 中，否则 x 稍后对 y 运行合并逻辑。

### 稍后合并逻辑

稍后合并操作只能从非运行、非死亡的区域x到运行的区域 y 进行。
稍后合并逻辑依赖于维护每个区域的合并到稍后集合，以及另一个预期将合并到此区域的区域集合。
实际上，从 x 到 y 的稍后合并操作将把 y 添加到 x 的稍后合并集合中，并将 x 添加到 y 的预期合并集合中。

当运行的区域完成运行时，该运行的区域将为所有预期的合并执行合并逻辑。

### 合并逻辑

合并操作只能在死亡的区域 x 和另一个区域 y 之间进行，y 可以是“过渡”或“准备”状态。
实际上，区域 x 被区域 y 吸收，因为 x 中的部分被移动到区域 y。

稍后合并操作也会被转发到区域 y，这样原本 x 要稍后合并的区域，现在 y 将稍后合并。

此外，如果区域 x 上有特定于实现的数据，将调用区域回调以将数据合并到区域 y 中。

合并操作完成后，可能会更新区域 y 的状态。
例如，如果区域 x 是“过渡”状态，那么区域 y 也应该被降级为过渡状态。
具体来说，如果区域 x 包含不是 y 的稍后合并目标，则应该将区域 y 标记为过渡状态。
这种降级到过渡状态是遵守第二个不变量所必需的。

### 移除区块（`removeChunk`）

从区域部分移除区块只是简单地更新该区域部分的状态为“死亡”或“存活”，以及空部分创建半径内的区域部分状态。
它不会更新任何区域状态，也不会清除区域部分。

### 区域运行开始（`tryMarkTicking`）

运行开始只是将状态迁移到运行状态，以便满足不变量 #2 和 #3。

### 区域运行结束（`markNotTicking`）

在运行结束时，区域的新状态并不立即已知。

首先，它必须处理其待处理的合并操作。

在处理完其待处理的合并操作后，它必须检查该区域是否现在正在等待合并到其他区域。
如果是，则转换为过渡状态。

否则，它将处理死亡部分的移除，并尝试拆分成更小的区域。
请注意，如果一个区域可以被拆分，它必须移除死亡部分，否则这将与最初构建该区域时使用的规则相矛盾。
